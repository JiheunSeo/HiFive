# [개발환경 세팅]

- Frontend
  | npm | 10.8.2 |
  | -------- | ------ |
  | openvidu | 2.30.0 |
- Backend
  | Spring boot | 3.3.1 |
  | ------------------- | ------------------ |
  | Swagger(Spring doc) | 2.6.0 |
  | S3 | 2.2.6 |
  | QueryDsl | 5.0.0 |
  | Openvidu | 2.30.0 |
  | jdk | 17 |
  | mysql | 8.0 |
  | redis | 7.0 |
  | ORM | JPA(Hibernate) |
  | Flask | python 3.10-slim |
  | intellij | 2024.1.4(ultimate) |
- Server
  | Ec2 | Ubuntu 20.04LTS |
  | -------- | --------------- |
  | Nginx | 1.18.0(Ubuntu) |
  | Jenkins | 2.452.3 |
  | Openvidu | 2.30.0 |
  | Kurento | 7.0.1 |
  | docker | 27.0.03 |

## 1. Docker, Docker-compose 설치

Docker 설치

```jsx
//패키지 업데이트
sudo apt update

//도커 다운로드를 위한 https 패키지 설치
sudo apt install apt-transport-https ca-certificates curl software-properties-common

//도커 레포지토리 접근을 위한 GPG Key 설정
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

//도커 레포지토리 등록
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"

//패키지 업데이트
sudo apt update

//도커 설치
sudo apt install docker-ce

//도커 실행 상태 확인
sudo systemctl status docker
```

Docker Compose 설치

```jsx
//도커 컴포즈 설치
sudo curl -L "https://github.com/docker/compose/releases/download/v2.5.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose

//도커 컴포즈 권한 부여
sudo chmod +x /usr/local/bin/docker-compose

//심볼릭 링크 연결
sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose

//도커 컴포즈 버전 확인
docker-compose --version
```

## 2. Nginx 설치 및 세팅

### 2-1. Nginx, letsencrypt, certbot 설치

```jsx
//패키지 업데이트
sudo apt update

//nginx 설치
sudo apt install nginx

//방화벽에 nginx 포트 열기
sudo ufw allow 'Nginx Full'

//letsencrypt 설치
sudo apt install letsencrypt

//certbot 설치 및 https 설정 자동화 인증서 발급
sudo apt install certbot
sudo certbot --nginx

//https통신을 위한 443포트 열기
sudo ufw allow 443
```

### 2-2. Nginx Conf 수정

경로 : etc/nginx/conf.d/default.conf

```jsx
server{
        listen 443 ssl;
        server_name i11a107.p.ssafy.io;

        location / {
                proxy_pass http://localhost:3000;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header Host $http_host;
        }

        location /login/oauth2/code/kakao {
                return 302 http://i11a107.p.ssafy.io:5442/login/oauth2/code/kakao?$query_string;
        }

        location /oauth2/authorization/kakao {
                return 302 http://i11a107.p.ssafy.io:5442/oauth2/authorization/kakao;
        }

        location /api/{
                proxy_pass http://localhost:5442;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header Host $http_host;
        }

        location /ws/{
                proxy_pass http://localhost:5442;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header Host $http_host;
                proxy_set_header Connection "upgrade";
                proxy_set_header Upgrade $http_upgrade;
        }

        location /service/{
                proxy_pass http://localhost:5001;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header Host $http_host;
        }

        ssl_certificate /etc/letsencrypt/live/i11a107.p.ssafy.io/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/i11a107.p.ssafy.io/privkey.pem;
        include /etc/letsencrypt/options-ssl-nginx.conf;
        ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

}
server{
        listen 80;
        location / {
                return 301 https://i11a107.p.ssafy.io$request_uri;
        }
}

```

### 2-3. Nginx 사용 명령어

```jsx
//시작
sudo service nginx start

//중지
sudo service nginx stop

//재시작
sudo service nginx restart
```

## 3. Jenkins 설치 및 실행

### 3-1. Jenkins 폴더 만들기 및 권한 부여

```jsx
doocker;
ㅣJenkins;
ㅣhome;
ㅣDockerfile;
ㅣdocker - compose.yml;
```

home에 권한 부여

```jsx
$ chmod -R 777 home
```

### 3-2. Jenkins 설치를 위한 DockerFile 생성

```jsx
FROM jenkins/jenkins:lts
USER root

# docker 설치
# 잰킨스내에서 docker를 사용할 수 있도록!
RUN apt-get update && \
 apt-get -y install apt-transport-https \
 ca-certificates \
 curl \
 gnupg2 \
 zip \
 unzip \
 software-properties-common && \
curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo "$ID")/gpg > /tmp/dkey; apt-key add /tmp/dkey && \
 add-apt-repository \
 "deb [arch=amd64] https://download.docker.com/linux/$(. /etc/os-release; echo "$ID") \
 $(lsb_release -cs) \
 stable" && \
 apt-get update && \
 apt-get -y install docker-ce

 # docker-compose 설치
 RUN curl -L "https://github.com/docker/compose/releases/download/1.28.5/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose && \
    chmod +x /usr/local/bin/docker-compose && \
    ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
```

### 3-3. docker-compose.yml 생성

```jsx
version: '3'
services:
  jenkins:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: 'jenkins'
    image: 'jenkins/jenkins:lts'
    restart: always
    user: root
    #privileged: true
    ports:
	    # 9090포트로 받아줌
      - 9090:8080
      - 50000:50000
    volumes:
      - /home/ubuntu/docker/jenkins/home:/var/jenkins_home
      - /var/run:/var/run:ro              # docker 실행 폴더 공유
      - /var/run/docker.sock:/var/run/docker.sock # docker 소켓 파일 마운트
    environment:
      TZ: "Asiz/Seoul"

```

### 3-4. 잰킨스 컨테이너 실행

```jsx
// docker compose 실행
sudo docker-compose up -d
```

### 3-5. 젠킨스 접속 및 플러그인 설치

`http://i11a107.p.ssafy.io:9090`

→ initialAdminPassword는 위에서 나오는 경로에서 복사

![alt text](../img/포팅1.png)

### 3-6. 젠킨스 자동 빌드 & 자동 배포

`새로운 아이템 -> pipeline -> 소스코드 관리 Git -> Gitlab hook`

```jsx
//ssh 키 발급
$ docker exec -it [jenkins 컨테이너 이름] ssh-keygen

// 생성 된 Public SSH 키 검색
$ docker exec -it [jenkins 컨테이너 이름] cat [확인한 Created directory]/id_rsa.pub

// 생성 된 Private SSH 키 검색
docker exec -it [jenkins 컨테이너 이름] cat /[확인한 Created directory]/id_rsa
```

위에서 발급한 키를

Settings → Deploy keys → Add deploy key를 발급한다.

**Jenkins gitlab token 저장**

![alt text](../img/포팅2.png)

### 3-7. Credentials 추가

![alt text](../img/포팅3.png)

- gitlab에 등록할 jenkins token용 credentials
- UserName, password credentials
- backend 민감한 정보 저장용 application-private.yml파일 credentials
- fontend 민감한 정보 저장용 .env파일 credentials

### 3-8. Tools 설정

- jenkins container에서 사용할 jdk17, gradle, nodejs 설치

![alt text](../img/포팅4.png)

![alt text](../img/포팅5.png)

### 3-9. Pipeline 설정

```jsx
pipeline {
    agent any

    environment {
        APPLICATION_PRIVATE = credentials('application-private')
        REACT_ENV = credentials('react-env')
    }

    tools {
        jdk ("jdk17")
        gradle ("gradle8.9")
        nodejs ("nodejs20")
    }

    stages {
        stage('Checkout Application Git Branch') {
            steps {
                git credentialsId: 'credential_gurwls0122',
                url:
                'https://lab.ssafy.com/s11-webmobile1-sub2/S11P12A107.git',
                branch: 'develop'
            }
            post {
                failure {
                    echo 'Repository clone failure !'
                }
                success {
                    echo 'Repository clone success !'
                }
            }
        }
        stage('spring application prviate setting'){
            steps{
                dir(path:'backend/src/main/resources'){
                    sh 'cp $APPLICATION_PRIVATE application-private.yml'
                }
            }
        }
        stage('react env setting'){
            steps{
                dir(path:'frontend'){
                    sh 'cp $REACT_ENV .env'
                }
            }
        }

        stage('gardle Jar Build') {
            steps {
                dir(path: 'backend/') {
                    sh 'chmod +x gradlew'
                    sh './gradlew clean bootjar -Dspring.profiles.active=prod'
                }
            }
            post {
                    failure {
                      echo 'Gradle jar build failure !'
                    }
                    success {
                      echo 'Gradle jar build success !'
                    }
            }
        }
        stage('Frontend Build'){
            steps{
                dir(path: 'frontend/'){
                    sh 'npm install'
                    sh 'npm run build'
                }
            }
            post{
                failure{
                    echo 'Frontend build Failure !'
                }
                success{
                    echo 'Frontend build success !'
                }
            }
        }


        stage('Clean Up Old Images') {
            steps {
                script {
                    sh '''
                    docker stop $(docker ps -q --filter "ancestor=hifive-frontend:latest") || true
                    docker stop $(docker ps -q --filter "ancestor=hifive-spring-application:latest") || true
                    docker stop $(docker ps -q --filter "ancestor=hifive-ai-server:latest") || true
                    docker rm $(docker ps -a -q --filter "ancestor=hifive-frontend:latest") || true
                    docker rm $(docker ps -a -q --filter "ancestor=hifive-spring-application:latest") || true
                    docker rm $(docker ps -a -q --filter "ancestor=hifive-ai-server:latest") || true
                    docker rmi hifive-frontend:latest || true
                    docker rmi hifive-spring-application:latest || true
                    docker rmi hifive-ai-server:latest || true
                    '''
                }
            }
        }

        stage('build docker') {
            steps {
                dir(path: 'backend/'){
                    sh "docker build -t hifive-spring-application:latest ."
                }
                dir(path: 'frontend/'){
                    sh "docker build -t hifive-frontend:latest ."
                }
                dir(path: 'ai-server/'){
                    sh "docker build -t hifive-ai-server:latest ."
                }
                sh "docker compose up -d --force-recreate"
            }
            post {
                    failure {
                      echo 'Docker build or run failure !'
                    }
                    success {
                      echo 'Docker build and run success !'
                    }
            }
        }
    }
}

```

### 3-10. Gitlab Webhook 설정

![alt text](../img/포팅6.png)

- gitlab의 master 혹은 develop에 push되었을 때 webhook을 이용하여 자동 ci/cd설정

## 4. OpenVidu 설치

```jsx
//관리자 권한 획득
sudo su

//openvidu 설치 dir로 접속
cd /opt

//openvidu download
curl https://s3-eu-west-1.amazonaws.com/aws.openvidu.io/install_openvidu_latest.sh | bash

//openvidu이동
cd openvidu

//openvidu를 실행하기 위한 env수정
vim .env

//openvidu 시작
./openvidu start
```

### 4-1. Openvidu default app제거

- 실제 openvidu를 커스텀 서버에서 사용하기 위해 default로 만들어지는 app 삭제.

```jsx
rm - rf / opt / openvidu / docker - compose.override.yml;
```

### 4-2. OpenVidu .env 세팅

```jsx
# For example: 198.51.100.1, or openvidu.example.com
DOMAIN_OR_PUBLIC_IP=i11a107.p.ssafy.io

# OpenVidu SECRET used for apps to connect to OpenVidu server and users to access to OpenVidu Dashboard
OPENVIDU_SECRET=

# Certificate type:
# - selfsigned:  Self signed certificate. Not recommended for production use.
#                Users will see an ERROR when connected to web page.
# - owncert:     Valid certificate purchased in a Internet services company.
#                Please put the certificates files inside folder ./owncert
#                with names certificate.key and certificate.cert
# - letsencrypt: Generate a new certificate using letsencrypt. Please set the
#                required contact email for Let's Encrypt in LETSENCRYPT_EMAIL
#                variable.
CERTIFICATE_TYPE=letsencrypt

# If CERTIFICATE_TYPE=letsencrypt, you need to configure a valid email for notifications
LETSENCRYPT_EMAIL=gurwls0122@naver.com

# Proxy configuration
# If you want to change the ports on which openvidu listens, uncomment the following lines

# Allows any request to http://DOMAIN_OR_PUBLIC_IP:HTTP_PORT/ to be automatically
# redirected to https://DOMAIN_OR_PUBLIC_IP:HTTPS_PORT/.
# WARNING: the default port 80 cannot be changed during the first boot
# if you have chosen to deploy with the option CERTIFICATE_TYPE=letsencrypt
HTTP_PORT=4442

# Changes the port of all services exposed by OpenVidu.
# SDKs, REST clients and browsers will have to connect to this port
HTTPS_PORT=4443

# Old paths are considered now deprecated, but still supported by default.
# OpenVidu Server will log a WARN message every time a deprecated path is called, indicating
# the new path that should be used instead. You can set property SUPPORT_DEPRECATED_API=false
# to stop allowing the use of old paths.
# Default value is true
# SUPPORT_DEPRECATED_API=false

# If true request to with www will be redirected to non-www requests
# Default value is false
# REDIRECT_WWW=false

# How many workers to configure in nginx proxy.
# The more workers, the more requests will be handled
# Default value is 10240
# WORKER_CONNECTIONS=10240

# Access restrictions
# In this section you will be able to restrict the IPs from which you can access to
# Openvidu API and the Administration Panel
# WARNING! If you touch this configuration you can lose access to the platform from some IPs.
# Use it carefully.

# This section limits access to the /dashboard (OpenVidu CE) and /inspector (OpenVidu Pro) pages.
# The form for a single IP or an IP range is:
# ALLOWED_ACCESS_TO_DASHBOARD=198.51.100.1 and ALLOWED_ACCESS_TO_DASHBOARD=198.51.100.0/24
# To limit multiple IPs or IP ranges, separate by commas like this:
# ALLOWED_ACCESS_TO_DASHBOARD=198.51.100.1, 198.51.100.0/24
# ALLOWED_ACCESS_TO_DASHBOARD=

# This section limits access to the Openvidu REST API.
# The form for a single IP or an IP range is:
# ALLOWED_ACCESS_TO_RESTAPI=198.51.100.1 and ALLOWED_ACCESS_TO_RESTAPI=198.51.100.0/24
# To limit multiple IPs or or IP ranges, separate by commas like this:
# ALLOWED_ACCESS_TO_RESTAPI=198.51.100.1, 198.51.100.0/24
# ALLOWED_ACCESS_TO_RESTAPI=

# Whether to enable recording module or not
OPENVIDU_RECORDING=true
```

- openvidu port 설정(4442, 4443)
- https 설정 : letsencrypt
- openvidu secret 저장
- openvidu recording 세팅 : `OPENVIDU_RECORDING = true`

### 4-3. OpenVidu 실행

```jsx
// openvidu 경로로 이동
cd opt/openvidu

// 관리자 권한 실행
sudo su

//openvidu 실행, 중지, 재시작
./openvidu start
./openvidu stop
./openvidu restart
```

## 5. CI/CD를 위한 Docker File 및 Docker-compose.yml 설정

- 단, 현재 프로젝트에 모두 올라가있기 때문에 따로 설정할 필요는 없음.

**Backend Server(Spring) - DockerFile**

```jsx
FROM openjdk:17
ENV SPRING_PROFILES_ACTIVE=prod
RUN mkdir -p /app/recordings
ARG JAR_FILE=build/libs/*.jar
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java", "-Duser.timezone=Asia/Seoul", "-jar", "/app.jar", "--spring.profiles.active=${SPRING_PROFILES_ACTIVE}"]
```

**Backend Server(AI) - DockerFile**

```jsx
# Python 3.10 버전을 사용
FROM python:3.10-slim

# 작업 디렉토리 설정
WORKDIR /app

# 시스템 패키지 업데이트 및 빌드 도구 설치
RUN apt-get update && apt-get install -y \
    build-essential \
    cmake \
    libglib2.0-0 \
    libsm6 \
    libxext6 \
    libxrender-dev \
    libgl1-mesa-glx \
    && rm -rf /var/lib/apt/lists/*

# 필요한 패키지 복사 및 설치
COPY requirements.txt requirements.txt

# 문제 패키지 별도 설치 (예: dlib)
RUN pip install --no-cache-dir dlib==19.22.1

# 나머지 패키지 설치
RUN pip install --no-cache-dir -r requirements.txt

# 모델 파일 복사
COPY model/shape_predictor_68_face_landmarks.dat model/shape_predictor_68_face_landmarks.dat

# 애플리케이션 파일 복사
COPY . .

# Flask 애플리케이션 실행
CMD ["python", "app.py"]
```

**Frontend Server(React) - DockerFile**

```jsx
# Build stage
FROM node:20-alpine as build
WORKDIR /app
COPY package*.json ./

RUN npm install
COPY . .
CMD ["npm", "start"]
EXPOSE 3000
```

**docker-compose.yml**

```jsx
services: # container setting info
  portainer-docker:
    container_name: portainer-container
    image: portainer/portainer
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer_data:/data
    networks:
      - db-network
    ports:
      - "5000:9000"

  mysql-docker:
    container_name: mysql-container
    image: mysql:8.0
    volumes:
      - db-mysql:/var/lib/mysql
    restart: unless-stopped
    environment:
      - MYSQL_ROOT_PASSWORD=1q2w3e4r!
      - MYSQL_USER=hifive
      - MYSQL_PASSWORD=1q2w3e4r!
      - MYSQL_DATABASE=hifive
    networks:
      - db-network
    ports:
      - "3306:3306"

  redis-docker:
    container_name: redis-container
    image: redis:7.0
    ports:
      - "6380:6379"
    volumes:
      - db-redis:/var/lib/redis
    networks:
      - db-network

  spring-application:
    container_name: hifive_spring
    build:
      context: ./backend
      dockerfile: Dockerfile
    #    env_file:
    #      - .env
    environment:
      SPRING_DATASOURCE_URL: jdbc:mysql://mysql-container:3306/hifive
      SPRING_DATASOURCE_USERNAME: hifive
      SPRING_DATASOURCE_PASSWORD: 1q2w3e4r!
      SPRING_DATASOURCE_DRIVER-CLASS-NAME: com.mysql.cj.jdbc.Driver
    ports:
      - "5442:8080"
    networks:
      - db-network
      - webnet
    depends_on:
      - mysql-docker
      - redis-docker

  frontend:
    depends_on:
      - spring-application
    container_name: hifive-react
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    networks:
      - webnet

  ai-server:
    container_name: hifive_flask
    build:
      context: ./ai-server
      dockerfile: Dockerfile
    ports:
      - "5001:5000"
    networks:
      - webnet

volumes:
  db-mysql:
  db-redis:
  portainer_data:

networks:
  db-network:
    driver: bridge
  webnet:
```

- redis 및 mysql도 세팅

## 6. 서버에서 사용하는 환경변수

- Jenkins에서 credentials로 등록하는 private한 변수값들

**application-private.yml(Spring boot)**

```jsx
db:
  host: localhost
  port: 3306
  database: hifive
  username: hifive
  password: 1q2w3e4r!

kakao:
  client-id: "283fe1da283e812e006d45776653b704"
  client-secret: "3VvRSCqDyV3YC7FauDVoTmALqdcQA6pL"

aws:
  accessKey: "AKIA4MTWNIVAPQY7H5MS"
  secretKey: "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"
  bucket: "hifivebucket2024"
  region: "ap-northeast-2"

jwt:
  issuer: gurwls@naver.com
  secret_key: 1q2w3e4r!

openvidu:
  url: https://i11a107.p.ssafy.io:4443
  secret: ssafy1234
```

**.env(react)**

```jsx
REACT_APP_END_POINT="https://i11a107.p.ssafy.io"
REACT_APP_AUTH_END_POINT="https://i11a107.p.ssafy.io"
WDS_SOCKET_PORT=443
WDS_SOCKET_PATH=/ws
WDS_SOCKET_HOST=0.0.0.0
```

# 사용 포트

| 컨테이너                         | 포트 번호 |
| -------------------------------- | --------- |
| spring                           | 5442      |
| react                            | 3000      |
| flask                            | 5001      |
| portainer(도커 컨테이너 관리 툴) | 5000      |
| jenkins                          | 9090      |
| redis                            | 6380      |
| mysql                            | 3306      |
| openvidu media server            | 4443      |
